import {
    Center,
    HStack,
    Divider,
    Container,
    Stack,
    Flex,
    Box,
    Heading,
    Text,
    useDisclosure,
    Button,
    Image,
    Icon,
    IconButton,
    createIcon,
    IconProps,
    useColorModeValue,
    ModalOverlay,
    ModalContent,
    ModalHeader,
    ModalCloseButton,
    ModalBody,
    Modal,
    ModalFooter,
    Grid,
    GridItem,
    ButtonGroup,
    AspectRatio,
    ListIcon,
    Spacer,
    chakra,
    shouldForwardProp
} from '@chakra-ui/react';
import projects from '../public/data/ProjectText';



## Background
Prior to working on this project, I had little experience with building websites without the use of frameworks and UI tools such as React and Material UI. To combat this and deepen my knowledge, I set out to see what kind of design and implementation I could come up with using plain and simple HTML and CSS. 
<br/>
One of my main goals was to have smooth, and consistent CSS animations when interacting with the interface. Aspects like word highlighting and satisfying dropdown menus were a priority. This project taught me a lot about animating keyframes and syncing elements between transitions. 
<br/>
Towards the end of development, I found I was having trouble with animating the dropdown menus, where it became tedious trying to combine multiple animations at the same time, while still balancing the color of certain elements. I ended up breaking my rules and using jQuery for that alone. The use of jQuery greatly simplified these DOM and CSS manipulations.
<br/>
<Center
    py={'1em'}>
            ![The menus.](/screenshots/dog2.png_3282_850)
</Center>
<br/>
## Breakdown
The primary script is split into a few different key operations. The first is the word (sentence) generator that takes a JSON of sample words and uses a simple algorithm to randomize them by their length. 
<br/>
The second is a counter that keeps track of the time elapsed and updates the statistics based on it. This one proved tricky at first as I was accustomed to the way state works in frameworks such as React. This meant continuously updating elements was not as simple as creating a state and having it update on its own.
<br/>
<Center
    py={'1em'}>
            ![The typing screen.](/screenshots/dog1.png_3282_2026)

</Center>
<br/>
The last key operation is what I used to alleviate the previously mentioned problem. It’s a rendering call based on the time elapsed, used to calculate the correct statistics and display them to the user.
<br/>

## The Full Stack
<Flex
w={'100%'}
px={{ base: '1.5em', sm: '1.5em', md: '2em', lg: '3em' }}>
- Python
- PyQT6
</Flex>

<br/>
This was never intended to be a web application, so I chose to use the PyQT toolkit as it’s flexible, open source, and most importantly, compatible with Python.
<br/>